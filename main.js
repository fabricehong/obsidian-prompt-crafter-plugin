/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => PromptCrafterPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian5 = require("obsidian");

// src/pcBlock.ts
var import_obsidian4 = require("obsidian");

// src/prompt-resolver.ts
var import_obsidian = require("obsidian");

// src/markdown-leveler.ts
function relevelMarkdownHeaders(markdown, targetBaseLevel) {
  const lines = markdown.split("\n");
  let adjustedMarkdown = "";
  let minCurrentLevel = Infinity;
  lines.forEach((line) => {
    const match = line.match(/^(#+)/);
    if (match) {
      const level = match[0].length;
      if (level < minCurrentLevel) {
        minCurrentLevel = level;
      }
    }
  });
  const levelOffset = targetBaseLevel - minCurrentLevel;
  lines.forEach((line) => {
    const match = line.match(/^(#+)(\s+.*)/);
    if (match) {
      let newLevel = match[1].length + levelOffset;
      if (newLevel < 1)
        newLevel = 1;
      if (newLevel > 6) {
        const boldText = `**${newLevel - 6}. ${match[2].trim()}**`;
        adjustedMarkdown += boldText + "\n";
      } else {
        const newHeader = `${"#".repeat(newLevel)}${match[2]}`;
        adjustedMarkdown += newHeader + "\n";
      }
    } else {
      adjustedMarkdown += line + "\n";
    }
  });
  return adjustedMarkdown.trim();
}
function computePlaceHoldersMarkdownLevel(markdown) {
  const lines = markdown.split("\n");
  let currentLevel = 0;
  let result = {};
  lines.forEach((line) => {
    const headerMatch = line.match(/^(#+)/);
    if (headerMatch) {
      currentLevel = headerMatch[0].length;
    }
    const placeholderMatches = [...line.matchAll(new RegExp(PLACEHOLDER_REGEX, "g"))];
    placeholderMatches.forEach((match) => {
      const placeholderName = match[1];
      if (placeholderName && !(placeholderName in result)) {
        result[placeholderName] = currentLevel;
      }
    });
    if (!headerMatch && !line.trim().startsWith("{{")) {
      currentLevel = 0;
    }
  });
  return result;
}

// src/prompt.ts
var PLACEHOLDER_REGEX = "\\{\\{([\\w-]+)\\}\\}";
var Prompt = class {
  constructor(template, filepath, section = void 0) {
    this.template = template;
    this.filepath = filepath;
    this.section = section;
  }
  remplacePlaceholders(variables) {
    const placeholdersLevels = computePlaceHoldersMarkdownLevel(this.template);
    return this.template.replace(new RegExp(PLACEHOLDER_REGEX, "g"), (match, variableName) => {
      if (!variables.hasOwnProperty(variableName)) {
        throw new Error(`Variable '${variableName}' not found`);
      }
      const placeholderLevel = placeholdersLevels[variableName];
      const markdown = variables[variableName];
      return relevelMarkdownHeaders(markdown, placeholderLevel + 1);
    });
  }
  isEqual(other) {
    return this.filepath === other.filepath && this.section === other.section;
  }
  getPromptId() {
    return !!this.section ? `${this.filepath}#${this.section}` : this.filepath;
  }
};

// src/pc-block-utils.ts
function getCodeBloc(content) {
  const regex = /^\s*```(\w*)\n([\s\S]*?)\n```\s*$/;
  const correspondance = content.match(regex);
  if (correspondance) {
    return {
      content: correspondance[2].trim(),
      blocType: correspondance[1] === "" ? void 0 : correspondance[1]
    };
  }
  return void 0;
}
function removeFrontmatter(content) {
  const regex = /^---[\s\S]+?---\n?/;
  return content.replace(regex, "");
}

// src/prompt-resolver.ts
var PromptResolver = class {
  constructor(app, promptHistory = []) {
    this.app = app;
    this.promptHistory = promptHistory;
  }
  async resolvePrompt(prompt, sourceFile) {
    const newPromptHistory = this.promptHistory.concat(prompt);
    if (this.promptHistory.some((p) => p.isEqual(prompt))) {
      const chainDescription = newPromptHistory.map((p) => {
        if (p.isEqual(prompt)) {
          return `*${p.getPromptId()}*`;
        }
        return p.getPromptId();
      }).join(" -> ");
      throw new Error(`Circular reference detected: ${chainDescription}`);
    }
    const file = this.app.vault.getAbstractFileByPath(sourceFile);
    const variables = {};
    if (!(file instanceof import_obsidian.TFile)) {
      throw new Error("no instance of TFile");
    }
    const fileCache = this.app.metadataCache.getFileCache(file);
    if (!fileCache) {
      throw new Error("Aucun cache de fichier trouv\xE9.");
    }
    const frontmatter = fileCache.frontmatter || {};
    for (const key in frontmatter) {
      const linktext = frontmatter[key];
      const linkTargetContent = await this.determineVariableValue(linktext, file.path);
      if (!linkTargetContent) {
        variables[key] = linktext;
      } else {
        const withoutFrontmatter = removeFrontmatter(linkTargetContent.content);
        const codeBlock = getCodeBloc(withoutFrontmatter);
        if (codeBlock) {
          if (codeBlock.blocType === BLOCK_NAME) {
            const newPrompt = new Prompt(
              codeBlock.content,
              linkTargetContent.filepath,
              linkTargetContent.section
            );
            const promptResolver = new PromptResolver(this.app, newPromptHistory);
            variables[key] = await promptResolver.resolvePrompt(newPrompt, linkTargetContent.filepath);
          } else {
            variables[key] = codeBlock.content;
          }
        } else {
          variables[key] = withoutFrontmatter;
        }
      }
    }
    return prompt.remplacePlaceholders(variables);
  }
  async determineVariableValue(linktext, mainfilePath) {
    const parsed = this.parseLinktext(linktext);
    if (!parsed) {
      return void 0;
    }
    const { path, subpath } = parsed;
    const destFile = this.app.metadataCache.getFirstLinkpathDest(path, mainfilePath);
    if (!destFile) {
      throw new Error(`File '${path}' not found`);
    }
    const linkedFile = this.app.vault.getAbstractFileByPath(destFile.path);
    if (!(linkedFile instanceof import_obsidian.TFile)) {
      throw new Error("no instance of TFile");
    }
    let content = await this.app.vault.read(linkedFile);
    let result;
    if (subpath) {
      result = this.extractSectionContent(content, subpath);
    } else {
      result = content;
    }
    return {
      content: result,
      filepath: destFile.path,
      section: subpath
    };
  }
  parseLinktext(linktext) {
    const match = linktext.match(/\[\[([^\]]+?)(#([^#]+?))?\]\]/);
    if (match) {
      const linkAndLabel = match[1].split("|");
      return { path: linkAndLabel[0], subpath: match[3] };
    }
    return void 0;
  }
  extractSectionContent(content, subpath) {
    const lines = content.split("\n");
    let sectionContent = "";
    let inSection = false;
    let currentLevel = 0;
    for (const line of lines) {
      const headerMatch = line.match(/^(#+)\s+(.*)/);
      if (headerMatch) {
        const level = headerMatch[1].length;
        const title = headerMatch[2].trim();
        if (inSection && level <= currentLevel) {
          break;
        }
        if (title === subpath) {
          inSection = true;
          currentLevel = level;
          continue;
        }
      }
      if (inSection) {
        sectionContent += line + "\n";
      }
    }
    return sectionContent.trim();
  }
};

// src/CopyPromptModal.ts
var import_obsidian2 = require("obsidian");
var CopyPromptModal = class extends import_obsidian2.Modal {
  constructor(app, prompt, onSubmit) {
    super(app);
    this.onSubmit = onSubmit;
    this.prompt = prompt;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.createEl("h1", { text: "Prompt" });
    const textarea = contentEl.createEl("textarea", {
      attr: {
        style: "width: 100%; box-sizing: border-box; margin-bottom: 20px;"
        // Assure que le textarea prend toute la largeur et ajoute un peu d'espace en dessous
      }
    });
    textarea.value = this.prompt;
    textarea.rows = 10;
    const buttonContainer = contentEl.createEl("div", {
      attr: {
        style: "text-align: right;"
        // Alignement du bouton à droite
      }
    });
    const button = buttonContainer.createEl("button", { text: "Copy" });
    button.addClass("mod-cta");
    button.addEventListener("click", () => {
      this.close();
      this.onSubmit(textarea.value);
    });
  }
  onClose() {
    let { contentEl } = this;
    contentEl.empty();
  }
};

// src/ErrorModal.ts
var import_obsidian3 = require("obsidian");
var ErrorModal = class extends import_obsidian3.Modal {
  constructor(app, message) {
    super(app);
    this.message = message;
  }
  onOpen() {
    const { contentEl } = this;
    const messageEl = contentEl.createEl("p");
    messageEl.setText(this.message);
    const okButton = contentEl.createEl("button", {
      text: "OK",
      cls: "mod-cta"
      // Utilise une classe pour ajouter des styles spécifiques si nécessaire
    });
    okButton.addEventListener("click", () => {
      this.close();
    });
    contentEl.style.display = "flex";
    contentEl.style.flexDirection = "column";
    contentEl.style.alignItems = "center";
    contentEl.style.justifyContent = "center";
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/pcBlock.ts
var BLOCK_NAME = "pc";
var PcBlock = class {
  constructor(plugin) {
    this.plugin = plugin;
    this.plugin.registerMarkdownCodeBlockProcessor(
      BLOCK_NAME,
      async (source, el, ctx) => {
        this.blockTgHandler(source, el, ctx);
      }
    );
  }
  async blockTgHandler(source, container, { sourcePath: path }) {
    setTimeout(async () => {
      const preElement = document.createElement("pre");
      preElement.style.whiteSpace = "pre-wrap";
      const codeElement = document.createElement("code");
      codeElement.textContent = source;
      preElement.appendChild(codeElement);
      container.appendChild(preElement);
      this.addTGMenu(container, source, path);
    }, 100);
  }
  addTGMenu(el, source, sourcePath) {
    var _a;
    const div = document.createElement("div");
    div.classList.add("plug-tg-tgmenu", "plug-tg-flex", "plug-tg-justify-end");
    const generateSVG = `<svg viewBox="0 0 100 100" class="svg-icon GENERATE_ICON"><defs><style>.cls-1{fill:none;stroke:currentColor;stroke-linecap:round;stroke-linejoin:round;stroke-width:4px;}</style></defs><g id="Layer_2" data-name="Layer 2"><g id="VECTOR"><rect class="cls-1" x="74.98" y="21.55" width="18.9" height="37.59"></rect><path class="cls-1" d="M38.44,27.66a8,8,0,0,0-8.26,1.89L24.8,34.86a25.44,25.44,0,0,0-6,9.3L14.14,56.83C11.33,64.7,18.53,67.3,21,60.9" transform="translate(-1.93 -15.75)"></path><polyline class="cls-1" points="74.98 25.58 56.61 18.72 46.72 15.45"></polyline><path class="cls-1" d="M55.45,46.06,42.11,49.43,22.76,50.61c-8.27,1.3-5.51,11.67,4.88,12.8L46.5,65.78,53,68.4a23.65,23.65,0,0,0,17.9,0l6-2.46" transform="translate(-1.93 -15.75)"></path><path class="cls-1" d="M37.07,64.58v5.91A3.49,3.49,0,0,1,33.65,74h0a3.49,3.49,0,0,1-3.45-3.52V64.58" transform="translate(-1.93 -15.75)"></path><path class="cls-1" d="M48,66.58v5.68a3.4,3.4,0,0,1-3.34,3.46h0a3.4,3.4,0,0,1-3.34-3.45h0V65.58" transform="translate(-1.93 -15.75)"></path><polyline class="cls-1" points="28.75 48.05 22.66 59.3 13.83 65.61 14.41 54.5 19.11 45.17"></polyline><polyline class="cls-1" points="25.17 34.59 43.75 0.25 52.01 5.04 36.39 33.91"></polyline><line class="cls-1" x1="0.25" y1="66.92" x2="13.83" y2="66.92"></line></g></g></svg>`;
    const button = this.createRunButton("Generate Text", generateSVG);
    button.addEventListener("click", async () => {
      console.log("trigger");
      try {
        const promptResolver = new PromptResolver(this.plugin.app);
        let resolvedPrompt = await promptResolver.resolvePrompt(new Prompt(source, sourcePath), sourcePath);
        new CopyPromptModal(this.plugin.app, resolvedPrompt, (result) => {
          this.copyToClipboard(result);
          new import_obsidian4.Notice("Prompt copied to clipboard", 3e3);
        }).open();
      } catch (e) {
        new ErrorModal(this.plugin.app, e.message).open();
        throw e;
      }
    });
    div.appendChild(button);
    (_a = el.parentElement) == null ? void 0 : _a.appendChild(div);
  }
  async copyToClipboard(texte) {
    try {
      await navigator.clipboard.writeText(texte);
      console.log("Texte copi\xE9 dans le presse-papier");
    } catch (err) {
      console.error("Erreur lors de la copie dans le presse-papier", err);
    }
  }
  createRunButton(label, svg) {
    const button = document.createElement("div");
    button.classList.add("clickable-icon");
    button.setAttribute("aria-label", label);
    button.innerHTML = svg;
    return button;
  }
};

// src/main.ts
var DEFAULT_SETTINGS = {
  mySetting: "default"
};
var PromptCrafterPlugin = class extends import_obsidian5.Plugin {
  async onload() {
    await this.loadSettings();
    new PcBlock(this);
  }
  onunload() {
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
};
